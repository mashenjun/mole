package prom

import (
	"github.com/mashenjun/mole/consts"
	"github.com/prometheus/common/model"
	"strconv"
	"testing"
)

var tsHasGap = []int64{
	1631071800, 1631071815, 1631071830, 1631072070, 1631072085, 1631072100, 1631072115, 1631072130, 1631072145,
	1631072160, 1631072175, 1631072190, 1631072205, 1631072220, 1631072235, 1631072250, 1631072265, 1631072280,
	1631072295, 1631072310, 1631072325, 1631072340, 1631072355, 1631072370, 1631072385, 1631072400, 1631072415,
	1631072430, 1631072445, 1631072460, 1631072475, 1631072490, 1631072505, 1631072520, 1631072535, 1631072550,
	1631072565, 1631072580, 1631072595, 1631072610, 1631072625, 1631072640, 1631072655, 1631072670, 1631072685,
	1631072700, 1631072715, 1631072730, 1631072745, 1631072760, 1631072775, 1631072790, 1631072805, 1631072820,
	1631072835, 1631072850, 1631072865, 1631072880, 1631072895, 1631072910, 1631072925, 1631072940, 1631072955,
	1631072970, 1631072985, 1631073000, 1631073015,
}

var tsNoGap = []int64{
	1631071800, 1631071815, 1631071830, 1631071845, 1631071860, 1631071875, 1631071890, 1631071905, 1631071920,
	1631071935, 1631071950, 1631071965, 1631071980, 1631071995, 1631072010, 1631072025, 1631072040, 1631072055,
	1631072070, 1631072085, 1631072100, 1631072115, 1631072130, 1631072145, 1631072160, 1631072175, 1631072190,
	1631072205, 1631072220, 1631072235, 1631072250, 1631072265, 1631072280, 1631072295, 1631072310, 1631072325,
	1631072340, 1631072355, 1631072370, 1631072385, 1631072400, 1631072415, 1631072430, 1631072445, 1631072460,
	1631072475, 1631072490, 1631072505, 1631072520, 1631072535, 1631072550, 1631072565, 1631072580, 1631072595,
	1631072610, 1631072625, 1631072640, 1631072655, 1631072670, 1631072685, 1631072700, 1631072715, 1631072730,
	1631072745, 1631072760, 1631072775, 1631072790, 1631072805, 1631072820, 1631072835, 1631072850, 1631072865,
	1631072880, 1631072895, 1631072910, 1631072925, 1631072940, 1631072955, 1631072970, 1631072985, 1631073000,
	1631073015, 1631073030, 1631073045, 1631073060, 1631073075, 1631073090, 1631073105, 1631073120, 1631073135,
	1631073150, 1631073165, 1631073180, 1631073195, 1631073210, 1631073225, 1631073240, 1631073255, 1631073270,
	1631073285, 1631073300, 1631073315, 1631073330, 1631073345, 1631073360, 1631073375, 1631073390, 1631073405,
	1631073420, 1631073435, 1631073450, 1631073465, 1631073480, 1631073495, 1631073510, 1631073525, 1631073540,
	1631073555, 1631073570, 1631073585,
}

func TestTsToSlot(t *testing.T) {
	var startTs int64 = 1631066400
	input := tsHasGap
	output := make([]int, len(input))
	for i, ts := range input {
		output[i] =  tsToSlot(startTs, ts, consts.MetricStep)
	}
	if output[len(output)-1] - output[0] == len(output) -1 {
		t.Fatal("handle gap incorrectly")
	}
	if output[0] != 360 {
		t.Fatal("calculate offset incorrectly")
	}
}

func TestMergedGap(t *testing.T) {
	builder := NewMergedGapBuilder(2, 1631066400, consts.MetricStep, 480)
	streamHasGap := make([]model.SamplePair, len(tsHasGap))
	for i, ts := range tsHasGap {
		streamHasGap[i] = model.SamplePair{
			Timestamp: model.TimeFromUnix(ts),
			Value:     1,
		}
	}
	streamNoGap := make([]model.SamplePair, len(tsNoGap))
	for i, ts := range tsNoGap {
		streamNoGap[i] = model.SamplePair{
			Timestamp: model.TimeFromUnix(ts),
			Value:     1,
		}
	}
	builder.Push("has_gap", streamHasGap)
	builder.Push("no_gap", streamNoGap)
	mg := builder.Build()
	slot0 := tsToSlot(1631066400, 1631073015, 15)
	slot1 :=  tsToSlot(1631066400, 1631071845, 15)
	slot3 := tsToSlot(1631066400, 1631073585, 15)
	slot4 := tsToSlot(1631066400, 1631071800, 15)
	if mg.InGap(slot0) {
		t.Fatalf("%v should not in gap", slot0)
	}
	if !mg.InGap(slot1) {
		t.Fatalf("%v should in gap", slot1)
	}
	if mg.GetAlignedIdx("has_gap", slot4) != 0 {
		t.Fatal("aligned idx incorrect")
	}
	if mg.GetAlignedIdx("no_gap", slot4) != 0 {
		t.Fatal("aligned idx incorrect")
	}
	if mg.GetAlignedIdx("has_gap", slot0) != len(streamHasGap)-1 {
		t.Fatal("aligned idx incorrect")
	}
	if mg.GetAlignedIdx("no_gap", slot3) != len(streamNoGap)-1 {
		t.Fatal("aligned idx incorrect")
	}
}

func TestMergedGapOverlap(t *testing.T) {
	startTs , endTs := int64(1632525600), int64(1632526185)
	tsList := make([][]int64, 4)
	sp := make([][]model.SamplePair, 4)
	tsList[0] = []int64{1632525600,1632525615,1632525630,1632525645,1632525660,1632525675,1632525690,1632525705,1632525720,
		1632525735,1632525750,1632526005,1632526020,1632526035,1632526050,1632526065,1632526080,1632526095,1632526110,
		1632526125,1632526140,1632526155,1632526170,1632526185}
	tsList[1] = []int64{1632525600,1632525615,1632525630,1632525645,1632525660,1632525675,1632525690,1632525705,1632525720,
		1632525735,1632525750,1632525765,1632526005,1632526020,1632526035,1632526050,1632526065,1632526080,1632526095,
		1632526110,1632526125,1632526140,1632526155,1632526170,1632526185}
	tsList[2] = []int64{1632525600,1632525615,1632525630,1632525645,1632525660,1632525675,1632525690,1632525705,1632525720,
		1632525735,1632525750,1632526005,1632526020,1632526035,1632526050,1632526065,1632526080,1632526095,1632526110,
		1632526125,1632526140,1632526155,1632526170,1632526185}
	tsList[3] = []int64{1632525600,1632525615,1632525630,1632525645,1632525660,1632525675,1632525690,1632525705,1632525720,
		1632525735,1632525750,1632525765}

	for i, ts := range tsList {
		pair := make([]model.SamplePair, len(ts))
		for j, v := range ts  {
			pair [j] = model.SamplePair{
				Timestamp: model.TimeFromUnix(v),
				Value:     1,
			}
		}
		sp[i] = pair
	}
	size := tsToSlot(startTs, endTs, 15) + 1
	builder := NewMergedGapBuilder(4, 1632525600, consts.MetricStep, size)
	for i, v := range sp {
		builder.Push(strconv.Itoa(i), v)
	}
	gap := builder.Build()
	info, missCnt := gap.GetGapInfo()
	t.Log(info)
	if len(info) != 3 {
		t.Fatal("wrong")
	}
	if missCnt != 14 {
		t.Fatal("wrong")
	}
	if gap.InGap(0) {
		t.Fatal("wrong")
	}
	if !gap.InGap(20) {
		t.Fatal("wrong")
	}
}
